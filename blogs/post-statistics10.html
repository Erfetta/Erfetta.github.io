<!DOCTYPE html>
<html lang="it">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>HMWK ‚Äî Counting Process & Poisson Approximation</title>

  <!-- Stile del blog -->
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <link rel="icon" href="../images/favicon.png" type="image/png">

  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

  <!-- MathJax -->
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>

<body>
<header>
  <h1>üìö My Blog</h1>
  <nav>
    <a href="../index.html">Home</a>
    <a href="blog.html">Blog</a>
  </nav>
</header>

<main class="container">


<!-- ===========================
     INTRO
============================ -->
<section>
  <article class="card">
    <h2>Simulazione di un Counting Process e Approssimazione del Processo di Poisson</h2>
    <p>
      In questo homework simuleremo un processo di conteggio su un intervallo di tempo
      \([0,T]\), in cui gli eventi si verificano indipendentemente con un tasso medio
      costante \(\lambda\). Divideremo l‚Äôintervallo in micro-intervalli e genereremo
      un evento in ciascuno con probabilit√† \(\lambda/n\).
    </p>
    <p>
      Mostreremo che questo modello approssima un <strong>processo di Poisson</strong>
      e analizzeremo le sue propriet√† teoriche.
    </p>
  </article>
</section>


<!-- ===========================
     SIMULAZIONE INTERATTIVA
============================ -->
<section>
  <article class="card">
    <h3>üß™ Simulazione Interattiva</h3>

    <div class="grid" style="gap:10px;">
      <div>
        <label><strong>Œª</strong> (tasso)</label>
        <input id="lambda" type="number" step="0.1" min="0.1" value="5">
      </div>
      <div>
        <label><strong>T</strong> (intervallo di tempo)</label>
        <input id="T" type="number" step="0.1" min="0.1" value="1">
      </div>
      <div>
        <label><strong>n</strong> (sottointervalli)</label>
        <input id="n" type="number" min="100" value="5000">
      </div>
      <div>
        <label><strong>Simulazioni</strong></label>
        <input id="runs" type="number" min="10" value="2000">
      </div>
    </div>

    <button id="simulateBtn"><i class="fa-solid fa-play"></i> Simula</button>
    <span id="status" class="muted" style="margin-left:8px;"></span>


    <h4 style="margin-top:20px;">Traiettoria simulata \(N(t)\)</h4>
    <canvas id="trajChart" height="200"></canvas>

    <h4 style="margin-top:20px;">Distribuzione empirica di \(N(T)\)</h4>
    <canvas id="histChart" height="200"></canvas>

    <div id="resultsTable" style="margin-top:20px;"></div>
  </article>
</section>


<!-- ===========================
     DISCUSSIONE TEORICA
============================ -->
<section>
  <article class="card">
    <h3>üìê Che processo stiamo approssimando?</h3>
    <p>
      Dividendo l‚Äôintervallo \([0,T]\) in \(n\) pezzi, e generando eventi con probabilit√†
      \(\lambda/n\), il numero totale di eventi segue:
      \[
        N(T) \sim \mathrm{Bin}\!\left(n,\frac{\lambda}{n}\right).
      \]
      Quando \(n \to \infty\):
      \[
        \mathrm{Bin}\left(n,\frac{\lambda}{n}\right)
        \;\longrightarrow\;
        \mathrm{Poisson}(\lambda T).
      \]
    </p>

    <p>
      Il processo ottenuto √® quindi una approssimazione del
      <strong>processo di Poisson</strong> con tasso \(\lambda\), caratterizzato da:
    </p>

    <ul>
      <li>incrementi indipendenti</li>
      <li>incrementi stazionari</li>
      <li>\(N(t+s)-N(t)\sim \mathrm{Poisson}(\lambda s)\)</li>
      <li>tempi di attesa esponenziali \(\mathrm{Exp}(\lambda)\)</li>
    </ul>

    <p>
      Il parametro \(\lambda\) rappresenta il <strong>numero medio di eventi per unit√† di tempo</strong>.
      Per il processo di Poisson:
      \[
        \mathbb{E}[N(T)] = \lambda T, \qquad
        \mathrm{Var}(N(T)) = \lambda T.
      \]
    </p>
  </article>
</section>


<!-- ===========================
     CODICE JS DELLA SIMULAZIONE
============================ -->
<script>
let trajChart = null;
let histChart = null;

function simulateCounting(lambda, T, n) {
  const dt = T / n;
  const p = lambda / n;
  let count = 0;
  let trajectory = [];

  for (let i = 0; i < n; i++) {
    if (Math.random() < p) count++;
    trajectory.push(count);
  }

  return trajectory;
}

function poissonPMF(k, mean) {
  return Math.exp(-mean) * Math.pow(mean, k) / factorial(k);
}

function factorial(n) {
  if (n === 0) return 1;
  let r = 1;
  for (let i = 1; i <= n; i++) r *= i;
  return r;
}

document.getElementById("simulateBtn").addEventListener("click", () => {
  const lambda = parseFloat(document.getElementById("lambda").value);
  const T = parseFloat(document.getElementById("T").value);
  const n = parseInt(document.getElementById("n").value);
  const runs = parseInt(document.getElementById("runs").value);

  document.getElementById("status").textContent = "Simulazione in corso...";

  const traj = simulateCounting(lambda, T, n);

  let totals = [];
  for (let r = 0; r < runs; r++) {
    const tr = simulateCounting(lambda, T, n);
    totals.push(tr[n - 1]);
  }

  const maxK = Math.max(...totals);
  let bins = Array(maxK + 1).fill(0);
  totals.forEach(k => bins[k]++);

  const empirical = bins.map(x => x / runs);

  const mean = lambda * T;
  const theoretical = bins.map((_, k) => poissonPMF(k, mean));

  const labels = [...Array(maxK + 1).keys()];

  const ctx1 = document.getElementById("trajChart").getContext("2d");
  if (trajChart) trajChart.destroy();
  trajChart = new Chart(ctx1, {
    type: "line",
    data: {
      labels: traj.map((_, i) => (i / n).toFixed(3)),
      datasets: [
        {
          label: "N(t)",
          data: traj,
          borderWidth: 2,
          pointRadius: 0
        }
      ]
    }
  });

  const ctx2 = document.getElementById("histChart").getContext("2d");
  if (histChart) histChart.destroy();
  histChart = new Chart(ctx2, {
    type: "bar",
    data: {
      labels: labels,
      datasets: [
        {
          label: "Empirica",
          data: empirical,
          backgroundColor: "rgba(0,99,255,0.5)"
        },
        {
          label: "Poisson teorica",
          data: theoretical,
          type: "line",
          borderColor: "orange",
          borderWidth: 2,
          fill: false
        }
      ]
    }
  });

  let html = "<table><thead><tr><th>k</th><th>Empirica</th><th>Poisson</th></tr></thead><tbody>";
  for (let k = 0; k <= maxK; k++) {
    html += `<tr><td>${k}</td><td>${empirical[k].toFixed(4)}</td><td>${theoretical[k].toFixed(4)}</td></tr>`;
  }
  html += "</tbody></table>";

  document.getElementById("resultsTable").innerHTML = html;
  document.getElementById("status").textContent = "Fatto!";
});
</script>


</main>

<footer>
  <p>How to contact me:</p>
  <ul class="social-icons">
    <li><a href="mailto:fettuccia57@gmail.com"><i class="fas fa-envelope"></i></a></li>
    <li><a href="https://www.linkedin.com/in/simone-fettuccia-a88086332" target="_blank"><i class="fab fa-linkedin"></i></a></li>
    <li><a href="https://github.com/Erfetta" target="_blank"><i class="fab fa-github"></i></a></li>
  </ul>
</footer>

</body>
</html>
